#!/bin/sh

# shellcheck source=./stdlib.sh
# shellcheck source=./backend.sh

readonly PKGDIR="${PKGDIR:-"$(realpath "$(dirname "$0")")"}"
readonly METADATA_DIR="${PKGDIR}/metadata"
readonly WORLD="$METADATA_DIR/world"
readonly LOCKFILE="${PKGDIR}/pkg.lock"
readonly CACHE_DIR="${CACHE_DIR:-${PKGDIR}/source_cache}"
readonly PACKAGE_CACHE="${PACKAGE_CACHE:-${PKGDIR}/package_cache}"
readonly REPOSITORY_LIST="${REPOSITORY_LIST:-${PKGDIR}/repositories/main}"
readonly EXTENSION_DIR="${PKGDIR:?}/extensions"

readonly green="\x1b[32m"

parse_arguments() {
    _flag="$1"
    shift

    # Default values
    ACTION=""
    ARGUMENTS=""
    ACTIVATION=""
    VERBOSE="${VERBOSE:-0}"
    RESOLVE_DEPENDENCIES=1
    PARALLEL_DOWNLOADS=5
    DO_CLEANUP=1
    CERTIFICATE_CHECK=1
    CHECKSUM_CHECK=1
    INSTALL_FORCE=0
    CREATE_PACKAGE=0
    SHOW_INFO=0
    LIST_FILES=0
    PRINT_WORLD=0
    INSTALL_ROOT=""
    OPT_DEPS="${OPT_DEPS:-true}"
    BUILD_DEPS="${BUILD_DEPS:-false}"
    CHECK_DEPS="${CHECK_DEPS:-true}"
    ASK_CONFIRMATION="${ASK_CONFIRMATION:-true}"

    case "$_flag" in
        -B*)
            readonly ACTION="build"
            readonly BUILD_DEPS=true
            _flag="${_flag#-B}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    k) readonly CERTIFICATE_CHECK=0 ;;
                    s) readonly CHECKSUM_CHECK=0 ;;
                    d) readonly RESOLVE_DEPENDENCIES=0 ;;
                    j) readonly PARALLEL_DOWNLOADS="$1"; shift ;;
                    c) readonly DO_CLEANUP=0 ;;
                    v) readonly VERBOSE=1 ;;
                    *) 
                        if ! extension_parse_flag B "$_char" "$@"; then
                            log_error "Invalid option for -B: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -I*)
            readonly ACTION="install"
            _flag="${_flag#-I}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    b) readonly CREATE_PACKAGE=1
                       readonly BUILD_DEPS=true ;;
                    d) readonly RESOLVE_DEPENDENCIES=0 ;;
                    f) readonly INSTALL_FORCE=1 ;;
                    j) readonly PARALLEL_DOWNLOADS="$1"; shift ;;
                    c) readonly DO_CLEANUP=0 ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag I "$_char" "$@"; then
                            log_error "Invalid option for -I: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -U*)
            readonly ACTION="uninstall"
            _flag="${_flag#-U}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag U "$_char" "$@"; then
                            log_error "Invalid option for -U: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -A*)
            readonly ACTION="activation"
            _flag="${_flag#-A}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    u) readonly ACTIVATION="up" ;;
                    d) readonly ACTIVATION="down" ;;
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag A "$_char" "$@"; then
                            log_error "Invalid option for -U: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -Q*)
            readonly ACTION="query"
            _flag="${_flag#-Q}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    i) readonly SHOW_INFO=1 ;;
                    l) readonly LIST_FILES=1 ;;
                    w) readonly PRINT_WORLD=1 ;;
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag Q "$_char" "$@"; then
                            log_error "Invalid option for -Q: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -h|--help) print_usage ;;

        *)
            # Allow extensions to handle completely custom actions
            if ! extension_parse_action "$_flag" "$@"; then
                log_error "Unknown action: $_flag"
            fi
            ;;
    esac
}

print_usage() {
    cat <<- EOF
	Usage: pkg [ACTION] [OPTIONS] [PACKAGES...]

	ACTIONS:
	    -B [OPTIONS] <packages>    Build packages from source
	    -I [OPTIONS] <packages>    Install packages
	    -U [OPTIONS] <packages>    Uninstall packages
	    -A [OPTIONS] <packages>    Activate/deactivate packages
	    -Q [OPTIONS] [package]     Query package information
	    -E [OPTIONS] <extensions>  Manage extensions

	BUILD OPTIONS (-B):
	    -k    Disable certificate checking
	    -s    Disable checksum verification
	    -d    Disable dependency resolution
	    -j N  Set number of parallel downloads (default: 5)
	    -c    Keep build directory after completion
	    -v    Verbose output

	INSTALL OPTIONS (-I):
	    -r PATH  Set installation root directory
	    -b       Build packages before installing
	    -d       Disable dependency resolution
	    -f       Force reinstall even if already installed
	    -j N     Set number of parallel downloads (default: 5)
	    -c       Keep build directory after completion
	    -v       Verbose output

	UNINSTALL OPTIONS (-U):
	    -r PATH  Set installation root directory
	    -v       Verbose output

	ACTIVATION OPTIONS (-A):
	    -u       Activate (link) package files
	    -d       Deactivate (unlink) package files
	    -r PATH  Set installation root directory
	    -v       Verbose output

	QUERY OPTIONS (-Q):
	    -i       Show package information
	    -l       List files owned by package
	    -w       Print world file (all installed packages)
	    -r PATH  Set installation root directory
	    -v       Verbose output

	EXAMPLES:
	    # Build a package
	    pkg -B gcc

	    # Install with dependencies
	    pkg -I bash coreutils

	    # Install to alternate root
	    pkg -Ir /mnt/sysroot gcc coreutils

	    # Force rebuild and install
	    pkg -Ibf vim

	    # Uninstall package and unused dependencies
	    pkg -U vim

	    # Query package info
	    pkg -Qi bash

	    # List all installed packages
	    pkg -Qw

	    # Activate/deactivate packages
	    pkg -Au gcc
	    pkg -Ad bash
	EOF

    exit 0
}

install_package() (
    _pkg_name="$1"

    if backend_is_installed "$_pkg_name" && [ "$INSTALL_FORCE" = 0 ]; then
        log_warn "Package already installed: $_pkg_name. Skipping."
    fi

    log_debug "Running pre-install hooks for: $_pkg_name"
    run_hooks pre_install "$_pkg_name" || \
        log_error "Pre-install hook failed for: $_pkg_name"

    log_debug "Installing package files for: $_pkg_name"
    backend_install_files "$_pkg_name" || \
        log_error "Failed to install files for: $_pkg_name"

    log_debug "Registering package in database: $_pkg_name"
    backend_register_package "$_pkg_name" || \
        log_error "Failed to register package: $_pkg_name"

    log_debug "Activating package: $_pkg_name"
    backend_activate_package "$_pkg_name" || \
        log_error "Failed to activate package: $_pkg_name"

    log_debug "Running post install hooks for: $_pkg_name"
    run_hooks post_install "$_pkg_name" || \
        log_error "Post-install hook failed for: $_pkg_name"

    printf "%b[SUCCESS]%b: Successfully installed %s\n" "$green" "$def" "$_pkg_name"
)

main_install() (
    _requested_packages="$(backend_get_package_name "$*")" || \
        log_error "Failed to get package names from list"

    log_debug "Getting install order for packages: $_requested_packages"
    _install_order="$(backend_resolve_install_order "$_requested_packages")" || \
        log_error "Failed to resolve install order"

    _install_order="$(backend_ask_confirmation install "$_install_order")" || \
        log_error "Not proceeding"
    _install_order_names="$(get_field "$_install_order" 1)"

    log_debug "Install order is: [$_install_order_names]"

    if [ -z "$_install_order" ]; then
        echo "Nothing to do."
        return 0
    fi

    # Prepare any sources that need building
    log_debug "Preparing source for: $_install_order_names"
    backend_prepare_sources "$_install_order_names" || \
        log_error "Failed to prepare sources"

    _install_order_no_build_deps="$_install_order"
    # We need to go through and install all build dependencies to the host
    for pkg in $_install_order; do
        _pkg_name="${pkg%%|*}"
        if [ "$(get_field "$pkg" 3)" = "build" ]; then
            log_debug "Installing build dependency: $pkg"
            build_package "$_pkg_name" || log_error "Failed to build: $_pkg_name"
            INSTALL_ROOT="" install_package "$_pkg_name" || \
                log_error "Failed to install: $_pkg_name"
            _install_order_no_build_deps="$(remove_string_from_list \
                "$_pkg_name" "$_install_order_names")"
        fi
    done

    log_debug "Install order is: $_install_order"
    for pkg in $_install_order_names; do
        log_debug "Checking if we should build $pkg"
        if backend_want_to_build_package "$pkg"; then
            log_debug "We should! Trying to build package: $pkg"
            build_package "$pkg" || log_error "Failed to build: $pkg"
            install_package "$pkg" || log_error "Failed to install: $pkg"
        else
            log_debug "Installing package: $pkg"
            install_package "$pkg" || log_error "Failed to install: $pkg"
        fi
    done
)

build_package() (
    trap '[ "$DO_CLEANUP" = 1 ] && rm -rf ${PKGDIR:?}/build' INT TERM EXIT
    _pkg_name="$1"

    log_debug "Running pre-build hooks for package: $_pkg_name"
    run_hooks pre_build "$_pkg_name" || \
        log_error "Pre-build hook failed for: $_pkg_name"

    log_debug "Compiling package: $_pkg_name"
    backend_build_source "$_pkg_name" || \
        log_error "Failed to build source for: $_pkg_name"

    log_debug "Creating installable package for: $_pkg_name"
    backend_create_package "$_pkg_name" || \
        log_error "Failed to create package for: $_pkg_name"

    log_debug "Running post-build hooks for: $_pkg_name"
    run_hooks post_build "$_pkg_name" || \
        log_error "Post-build hook failed for: $_pkg_name"

    printf "%b[SUCCESS]%b: %b\n" "$green" "$def" "Successfully built $_pkg_name!"
)

main_build() (
    _requested_packages="$*"

    log_debug "Getting build order for: $_requested_packages"
    _build_order="$(backend_resolve_build_order "$_requested_packages")" || \
        log_error "Failed to resolve build order"

    if [ -z "$_build_order" ]; then
        echo "Nothing to do."
        return 0
    fi

    _build_order="$(backend_ask_confirmation build "$_build_order")" || \
        log_error "Not proceeding"
    _build_order_names="$(get_field "$_build_order" 1)"

    log_debug "Preparing sources"
    backend_prepare_sources "$_build_order_names" || \
        log_error "Failed to prepare sources"

    for pkg in $_build_order_names; do
        log_debug "Building package: $pkg"
        build_package "$pkg" || log_error "Failed to build: $pkg"
    done
)

uninstall_package() (
    _pkg_name="$1"

    log_debug "Checking if package is installed: $_pkg_name"
    log_debug "root is: $INSTALL_ROOT"
    if ! backend_is_installed "$_pkg_name"; then
        log_warn "Package not installed: $_pkg_name"
        exit 0
    fi

    log_debug "Running pre-uninstall hooks: $_pkg_name"
    run_hooks pre_uninstall "$_pkg_name" || \
        log_error "Pre-uninstall hook failed for: $_pkg_name"

    log_debug "Unactivating package: $_pkg_name"
    backend_unactivate_package "$_pkg_name" || \
        log_error "Failed to unactivate package"

    log_debug "Removing files for package: $_pkg_name"
    backend_remove_files "$_pkg_name" || \
        log_error "Failed to remove files for $_pkg_name"

    log_debug "Unregistering package in database: $_pkg_name"
    backend_unregister_package "$_pkg_name" || \
        log_error "Failed to unregister package: $_pkg_name"

    log_debug "Running post-uninstall hooks for: $_pkg_name"
    run_hooks post_uninstall "$_pkg_name" || \
        log_error "Post-uninstall hook failed for: $_pkg_name"

    printf "%b[SUCCESS]%b: %b\n" "$green" "$def" "Successfully uninstalled $_pkg_name!"
)

main_uninstall() (
    _requested_packages="$*"
    
    log_debug "Getting uninstall order for packages: $_requested_packages"
    _uninstall_order="$(backend_resolve_uninstall_order "$_requested_packages")" || \
        log_error "Failed to resolve uninstall order"

    _uninstall_order="$(backend_ask_confirmation uninstall "$_uninstall_order")" || \
        log_error "Not proceeding"
    _uninstall_order_names="$(get_field "$_uninstall_order" 1)"

    if [ -z "$_uninstall_order" ]; then
        echo "Nothing to do."
        return 0
    fi

    for pkg in $_uninstall_order_names; do
        log_debug "Uninstalling package: $pkg"
        uninstall_package "$pkg" || log_error "Failed to uninstall: $pkg"
    done
)

main_activation() (
    _requested_packages="$*"

    _activation_order="$(backend_ask_confirmation activation "$_requested_packages")" || \
        log_error "Not proceeding"

    _activation_order="$(get_field "$_activation_order" 1)"

    if [ "$ACTIVATION" = "up" ]; then
        backend_activate_package "$_requested_packages"
    elif [ "$ACTIVATION" = "down" ]; then
        backend_unactivate_package "$_requested_packages"
    elif [ -z "$ACTIVATION" ]; then
        log_error "Activation requested but no flag given. Use -Au or -Ad"
    fi
)

main_query() (
    _pkg_name="$1"

    log_debug "Running pre-query hooks for: $_pkg_name"
    run_hooks pre_query "$_pkg_name" || \
        log_error "Pre-query hook failed for: $_pkg_name"

    log_debug "Querying package: $_pkg_name"
    backend_query "$_pkg_name" || \
        log_error "Failed to query package: $_pkg_name"

    log_debug "Running post-query hooks for: $_pkg_name"
    run_hooks post_query "$_pkg_name" || \
        log_error "Pre-query hook failed for: $_pkg_name"
)

load_extensions() {

    . "${PKGDIR}/stdlib.sh" || exit 1
    . "${PKGDIR}/backend.sh" || log_error "Failed to load backend"

    [ -d "$EXTENSION_DIR" ] || \
        log_warn "Extenstion directory does not exist: $EXTENSION_DIR"

    for ext in "$EXTENSION_DIR"/*.sh; do
        _ext_name="$(basename "$ext")"
        if [ "$_ext_name" = "stdlib.sh" ] || [ "$_ext_name" = "backend.sh" ]; then
            continue 
        fi

        [ -f "$ext" ] || continue
        . "$ext" || log_error "Failed to load extension: $ext"
    done
}

extension_parse_flag() {
    _action="$1"
    shift

    run_hooks flag "$_action" "$@" || \
        log_error "Failed to run flag hooks"
}

extension_parse_action() {
    _action="$1"
    shift

    run_hooks action "$_action" "$@" || \
        log_error "Failed to run flag hooks"
}

main() {
    exec 9>|"$LOCKFILE"
    flock -n 9 || log_error "In main: Another instance is running!"

    load_extensions || log_error "Failed to load extensions"
    parse_arguments "$@" || log_error "Failed to parse arguments"
    backend_run_checks || log_error "One or more checks failed"

    case "${ACTION:-}" in
        install)    main_install "$ARGUMENTS" ;;
        build)      main_build "$ARGUMENTS" ;;
        uninstall)  main_uninstall "$ARGUMENTS" ;;
        activation) main_activation "$ARGUMENTS" ;;
        query)      main_query "$ARGUMENTS" ;;
        *)          run_hooks main "$ARGUMENTS"
    esac
}

main "$@"
