#!/bin/sh

readonly red="\x1b[31m"
readonly blue="\x1b[34m"
readonly yellow="\x1b[33m"
readonly green="\x1b[32m"
readonly def="\x1b[39m"

readonly PKGDIR="${PKGDIR:-"$(realpath "$(dirname "$0")")"}"
readonly METADATA_DIR="${PKGDIR}/metadata"
readonly WORLD="$METADATA_DIR/world"
readonly LOCKFILE="${PKGDIR}/pkg.lock"
readonly CACHE_DIR="${CACHE_DIR:-${PKGDIR}/source_cache}"
readonly PACKAGE_CACHE="${PACKAGE_CACHE:-${PKGDIR}/package_cache}"
readonly REPOSITORY_LIST="${REPOSITORY_LIST:-${PKGDIR}/repositories/*}"
readonly EXTENSION_DIR="${PKGDIR:?}/extensions"

parse_arguments() {
    _flag="$1"
    shift

    # Default values
    ACTION=""
    ARGUMENTS=""
    ACTIVATION=""
    VERBOSE=0
    RESOLVE_DEPENDENCIES=1
    PARALLEL_DOWNLOADS=5
    DO_CLEANUP=1
    CERTIFICATE_CHECK=1
    CHECKSUM_CHECK=1
    INSTALL_FORCE=0
    CREATE_PACKAGE=0
    SHOW_INFO=0
    LIST_FILES=0
    PRINT_WORLD=0
    INSTALL_ROOT=""

    case "$_flag" in
        -B*)
            readonly ACTION="build"
            _flag="${_flag#-B}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    k) readonly CERTIFICATE_CHECK=0 ;;
                    s) readonly CHECKSUM_CHECK=0 ;;
                    d) readonly RESOLVE_DEPENDENCIES=0 ;;
                    j) readonly PARALLEL_DOWNLOADS="$1"; shift ;;
                    c) readonly DO_CLEANUP=0 ;;
                    v) readonly VERBOSE=1 ;;
                    *) 
                        if ! extension_parse_flag "B" "$_char" "$@"; then
                            log_error "Invalid option for -B: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -I*)
            readonly ACTION="install"
            _flag="${_flag#-I}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    b) readonly CREATE_PACKAGE=1 ;;
                    d) readonly RESOLVE_DEPENDENCIES=0 ;;
                    f) readonly INSTALL_FORCE=1 ;;
                    j) readonly PARALLEL_DOWNLOADS="$1"; shift ;;
                    c) readonly DO_CLEANUP=0 ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag "I" "$_char" "$@"; then
                            log_error "Invalid option for -I: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -U*)
            readonly ACTION="uninstall"
            _flag="${_flag#-U}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag "U" "$_char" "$@"; then
                            log_error "Invalid option for -U: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -A*)
            readonly ACTION="activation"
            _flag="${_flag#-A}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    u) readonly ACTIVATION="up" ;;
                    d) readonly ACTIVATION="down" ;;
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag "U" "$_char" "$@"; then
                            log_error "Invalid option for -U: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -Q*)
            readonly ACTION="query"
            _flag="${_flag#-Q}"
            while [ -n "$_flag" ]; do
                _char="${_flag%"${_flag#?}"}"
                _flag="${_flag#?}"
                case "$_char" in
                    i) readonly SHOW_INFO=1 ;;
                    l) readonly LIST_FILES=1 ;;
                    w) readonly PRINT_WORLD=1 ;;
                    r) readonly INSTALL_ROOT="$(realpath "$1")"; shift ;;
                    v) readonly VERBOSE=1 ;;
                    *)
                        if ! extension_parse_flag "Q" "$_char" "$@"; then
                            log_error "Invalid option for -Q: -$_char"
                        fi
                        ;;
                esac
            done
            readonly ARGUMENTS="$*"
            ;;

        -h|--help) print_usage ;;

        *)
            # Allow extensions to handle completely custom actions
            if ! extension_parse_action "$_flag" "$@"; then
                log_error "Unknown action: $_flag"
            fi
            ;;
    esac
}

print_usage() {
    cat <<- EOF
	Usage: pkg [ACTION] [OPTIONS] [PACKAGES...]

	ACTIONS:
	    -B [OPTIONS] <packages>    Build packages from source
	    -I [OPTIONS] <packages>    Install packages
	    -U [OPTIONS] <packages>    Uninstall packages
	    -A [OPTIONS] <packages>    Activate/deactivate packages
	    -Q [OPTIONS] [package]     Query package information
	    -E [OPTIONS] <extensions>  Manage extensions

	BUILD OPTIONS (-B):
	    -k    Disable certificate checking
	    -s    Disable checksum verification
	    -d    Disable dependency resolution
	    -j N  Set number of parallel downloads (default: 5)
	    -c    Keep build directory after completion
	    -v    Verbose output

	INSTALL OPTIONS (-I):
	    -r PATH  Set installation root directory
	    -b       Build packages before installing
	    -d       Disable dependency resolution
	    -f       Force reinstall even if already installed
	    -j N     Set number of parallel downloads (default: 5)
	    -c       Keep build directory after completion
	    -v       Verbose output

	UNINSTALL OPTIONS (-U):
	    -r PATH  Set installation root directory
	    -v       Verbose output

	ACTIVATION OPTIONS (-A):
	    -u       Activate (link) package files
	    -d       Deactivate (unlink) package files
	    -r PATH  Set installation root directory
	    -v       Verbose output

	QUERY OPTIONS (-Q):
	    -i       Show package information
	    -l       List files owned by package
	    -w       Print world file (all installed packages)
	    -r PATH  Set installation root directory
	    -v       Verbose output

	EXAMPLES:
	    # Build a package
	    pkg -B gcc

	    # Install with dependencies
	    pkg -I bash coreutils

	    # Install to alternate root
	    pkg -Ir /mnt/sysroot gcc coreutils

	    # Force rebuild and install
	    pkg -Ibf vim

	    # Uninstall package and unused dependencies
	    pkg -U vim

	    # Query package info
	    pkg -Qi bash

	    # List all installed packages
	    pkg -Qw

	    # Activate/deactivate packages
	    pkg -Au gcc
	    pkg -Ad bash

	    # Install extension
	    pkg -Ei my-extension.sh
	EOF

    exit 1
}

log_error() {
    if [ -n "${BASH_VERSION+x}" ]; then
        _msg_prefix=" In ${FUNCNAME[1]}: (line ${BASH_LINENO[0]})"
    elif [ -n "${ZSH_VERSION+x}" ]; then
        _msg_prefix=" In ${funcstack[2]}:"
    fi

    printf "%b[ERROR]%b%s: %s\n" "$red" "$def" "${_msg_prefix:-}" "$1" >&2
    exit 1
}

log_warn() {
    printf "%b[WARNING]%b: %s\n" "$yellow" "$def" "$1" >&2
}

log_debug() {
    if [ -n "${BASH_VERSION+x}" ]; then
        _msg_prefix=" In ${FUNCNAME[1]}: (line ${BASH_LINENO[0]})"
    elif [ -n "${ZSH_VERSION+x}" ]; then
        _msg_prefix=" In ${funcstack[2]}:"
    fi

    [ "${VERBOSE:-0}" = 1 ] && \
        printf "%b[DEBUG]%b%s: %s\n" "$blue" "$def" "${_msg_prefix:-}" "$1" >&2
}

install_package() (
    _pkg_name="$1"

    log_debug "Running pre-install hooks for: $_pkg_name"
    run_hooks pre_install "$_pkg_name" || \
        log_error "Pre-install hook failed for: $_pkg_name"

    log_debug "Installing package files for: $_pkg_name"
    backend_install_files "$_pkg_name" || \
        log_error "Failed to install files for: $_pkg_name"

    log_debug "Registering package in database: $_pkg_name"
    backend_register_package "$_pkg_name" || \
        log_error "Failed to register package: $_pkg_name"

    log_debug "Activating package: $_pkg_name"
    backend_activate_package "$_pkg_name" || \
        log_error "Failed to activate package: $_pkg_name"

    log_debug "Running post install hooks for: $_pkg_name"
    run_hooks post_install "$_pkg_name" || \
        log_error "Post-install hook failed for: $_pkg_name"

    printf "%b[SUCCESS]%b: Successfully installed %s\n" "$green" "$def" "$_pkg_name"
)

main_install() (
    _requested_packages="$(backend_get_package_name "$*")" || \
        log_error "Failed to get package names from list"

    log_debug "Getting install order for packages: $_requested_packages"
    _install_order="$(backend_resolve_install_order "$_requested_packages")" || \
        log_error "Failed to resolve install order"

    if [ -z "$_install_order" ]; then
        echo "Nothing to do."
        return 0
    fi

    # Prepare any sources that need building
    log_debug "Preparing source for: $_install_order"
    backend_prepare_sources "$_install_order" || \
        log_error "Failed to prepare sources"

    log_debug "Install order is: $_install_order"
    _install_order_temp="$_install_order"
    for pkg in $_install_order_temp; do
        log_debug "Checking if we should build $pkg"
        if backend_want_to_build_package "$pkg"; then
            log_debug "We should! Trying to build package: $pkg"
            build_package "$pkg" || log_error "Failed to build: $pkg"
            # Some packages may be build dependencies of others,
            # so we need to install everything in order right now
            install_package "$pkg" || log_error "Failed to install: $pkg"
            remove_string_from_list "$pkg" "$_install_order"
        fi
    done

    # Install all packages
    for pkg in $_install_order; do
        log_debug "Installing package: $pkg"
        install_package "$pkg" || log_error "Failed to install: $pkg"
    done
)

build_package() (
    trap '[ "$DO_CLEANUP" = 1 ] && rm -rf ${PKGDIR:?}/build' INT TERM EXIT
    _pkg_name="$1"

    log_debug "Running pre-build hooks for package: $_pkg_name"
    run_hooks pre_build "$_pkg_name" || \
        log_error "Pre-build hook failed for: $_pkg_name"

    log_debug "Compiling package: $_pkg_name"
    backend_build_source "$_pkg_name" || \
        log_error "Failed to build source for: $_pkg_name"

    log_debug "Creating installable package for: $_pkg_name"
    backend_create_package "$_pkg_name" || \
        log_error "Failed to create package for: $_pkg_name"

    log_debug "Running post-build hooks for: $_pkg_name"
    run_hooks post_build "$_pkg_name" || \
        log_error "Post-build hook failed for: $_pkg_name"

    printf "%b[SUCCESS]%b: %b\n" "$green" "$def" "Successfully built $_pkg_name!"
)

main_build() (
    _requested_packages="$*"

    log_debug "Getting build order for: $_requested_packages"
    _build_order="$(backend_resolve_build_order "$_requested_packages")" || \
        log_error "Failed to resolve build order"

    if [ -z "$_build_order" ]; then
        echo "Nothing to do."
        return 0
    fi

    log_debug "Preparing sources"
    backend_prepare_sources "$_build_order" || \
        log_error "Failed to prepare sources"

    for pkg in $_build_order; do
        log_debug "Building package: $pkg"
        build_package "$pkg" || log_error "Failed to build: $pkg"
    done
)

uninstall_package() (
    _pkg_name="$1"

    log_debug "Checking if package is installed: $_pkg_name"
    log_debug "root is: $INSTALL_ROOT"
    if ! backend_is_installed "$_pkg_name"; then
        log_warn "Package not installed: $_pkg_name"
        exit 0
    fi

    log_debug "Running pre-uninstall hooks: $_pkg_name"
    run_hooks pre_uninstall "$_pkg_name" || \
        log_error "Pre-uninstall hook failed for: $_pkg_name"

    log_debug "Unactivating package: $_pkg_name"
    backend_unactivate_package "$_pkg_name" || \
        log_error "Failed to unactivate package"

    log_debug "Removing files for package: $_pkg_name"
    backend_remove_files "$_pkg_name" || \
        log_error "Failed to remove files for $_pkg_name"

    log_debug "Unregistering package in database: $_pkg_name"
    backend_unregister_package "$_pkg_name" || \
        log_error "Failed to unregister package: $_pkg_name"

    log_debug "Running post-uninstall hooks for: $_pkg_name"
    run_hooks post_uninstall "$_pkg_name" || \
        log_error "Post-uninstall hook failed for: $_pkg_name"

    printf "%b[SUCCESS]%b: %b\n" "$green" "$def" "Successfully uninstalled $_pkg_name!"
)

main_uninstall() (
    _requested_packages="$*"
    
    log_debug "Getting uninstall order for packages: $_requested_packages"
    _uninstall_order="$(backend_resolve_uninstall_order "$_requested_packages")" || \
        log_error "Failed to resolve uninstall order"
    
    for pkg in $_uninstall_order; do
        log_debug "Uninstalling package: $pkg"
        uninstall_package "$pkg" || log_error "Failed to uninstall: $pkg"
    done
)

main_activation() (
    _requested_packages="$*"
    if [ "$ACTIVATION" = "up" ]; then
        backend_activate_package "$_requested_packages"
    elif [ "$ACTIVATION" = "down" ]; then
        backend_unactivate_package "$_requested_packages"
    elif [ -z "$ACTIVATION" ]; then
        log_error "Activation requested but no flag given. Use -Au or -Ad"
    fi
)

main_query() (
    _pkg_name="$1"

    log_debug "Querying package: $_pkg_name"
    backend_query "$_pkg_name" || \
        log_error "Failed to query package: $_pkg_name"
)

load_extensions() {
    log_debug "Extension dir is: $EXTENSION_DIR"
    
    [ ! -d "$EXTENSION_DIR" ] || \
        log_warn "Extenstion directory does not exist: $EXTENSION_DIR"

    for ext in "$EXTENSION_DIR"/*.sh; do
        log_debug "Loading extension: $ext"
        [ -f "$ext" ] || continue
        . "$ext" || log_error "Failed to load extension: $ext"
    done
}

# Default stub - extensions can override this
extension_parse_flag() {
    # Args: action, flag_char, remaining_args...
    return 1  # Return 1 = flag not handled
}

# Default stub - extensions can override this
extension_parse_action() {
    # Args: flag, remaining_args...
    return 1  # Return 1 = action not handled
}

# Default stub - extensions can override this
extension_handle_action() {
    return 1  # Return 1 = action not handled
}

main() {
    exec 9>|"$LOCKFILE"
    flock -n 9 || log_error "In main: Another instance is running!"

    . ./stdlib.sh || log_error "Failed to load stdlib"
    . ./backend.sh || log_error "Failed to load backend"

    load_extensions || log_error "Failed to load extensions"
    parse_arguments "$@" || log_error "Failed to parse arguments"
    backend_run_checks || log_error "One or more checks failed"

    case "${ACTION:-}" in
        install)    main_install "$ARGUMENTS" ;;
        build)      main_build "$ARGUMENTS" ;;
        uninstall)  main_uninstall "$ARGUMENTS" ;;
        activation) main_activation "$ARGUMENTS" ;;
        query)      main_query "$ARGUMENTS" ;;
        *)          extension_augment_main "$ACTION" "$ARGUMENTS" || \
                        log_error "Invalid action: $ACTION";;
    esac
}

main "$@"
